## 为什么？
* 用锁能够实现数据的安全性，但会带来性能下降。
* 无锁能够基于线程并行提升程序性能，但是会带来安全性下降。
* 在无锁和重量级锁之间寻求平衡，故引入锁升级机制。
## 升级过程
无锁---->偏向锁---->轻量级锁---->重量级锁
## jdk5之前
* synchronized锁在jdk5之前就是纯重量级锁，基于Monitor对象实现的。由于Monitor是jvm底层实现的，底层代码是c++，本质是依赖于底层操作系统的Mutex Lock实现的。操作系统实现线程之间的切换需要从用户态到内核态的转换，需要耗费大量资源、时间。
## Monitor与java对象以及线程是如何关联？
1. 如果一个java对象被某个线程锁住，则该java对象的MarkWord字段中的LockWord指向monitor的起始地址。
2. Monitor的Owner字段会存放拥有相关联对象锁的线程id。
## 提前知识
* 偏向锁：MarkWord存储的是偏向的线程ID
* 轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针
* 重量锁：MarkWord存储的是指向堆中的monitor对象的指针
## 锁升级流程
1. 无锁
* 初始状态，一个对象被实例化后，如果还没有被任何线程竞争锁，那么它就位就处于无锁状态(001)
2. 偏向锁
* 单线程竞争。当线程A第一次竞争到锁时，通过操作修改MarkWord中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程<font color='green'>将永远不需要同步</font>。
* **当一段同步代码一直被同一个线程多次访问，由于只有一个线程，那么该线程在后续访问时便会自动获得锁**。
* hotspot的作者经过研究发现，大多数情况下：多线程中锁不仅不存在多线程竞争，还存在锁由同一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有一个线程执行同步时提高性能。
* 偏向锁会偏向于第一个访问锁的线程，如果接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也即偏向锁在资源没有竞争情况下消除了同步语句，懒的连CAS操作都不做了，直接提高程序性能。
    1. 偏向锁的持有
    锁在第一次被拥有的时候，记录下偏向线程ID，偏向锁标志位改为1。后续线程进入时会查看对象的MarkWord中记录的是不是自己的线程ID:
        * 如果相等，则表示偏向锁是偏向当前线程的，就不需要再尝试获取锁了。
        * 如果不等，表示发生了竞争，锁已经不是总是偏向一个线程了，这是会尝试使用CAS来替换MarkWord里面的线程ID。
        * 竞争成功，表示之前的线程不存在了，MarkWord里面的线程ID改为自己的线程ID，锁不会升级，仍然是偏向锁。
        * 竞争失败，这时候可能需要升级变为轻量级锁，才能保证线程间公平竞争锁。
        * <font color='green'>注意：偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的</font>。
    2. 偏向锁JVM命令
        * 适用Linux：
            > java -XX:+PrintFlagsInitial | grep BiasedLock*
        * 适用windows：
            > java -XX:+PrintFlagsInitial | findstr BiasedLock*
        * 返回结果：
            ```dos
            intx BiasedLockingBulkRebiasThreshold          = 20                                  {product}
            intx BiasedLockingBulkRevokeThreshold          = 40                                  {product}
            intx BiasedLockingDecayTime                    = 25000                               {product}
            intx BiasedLockingStartupDelay                 = 4000                                {product}
            bool TraceBiasedLocking                        = false                               {product}
            bool UseBiasedLocking                          = true                                {product}
            ```
        * 重要参数解析：
            1. UseBiasedLocking：是否启用偏向锁（若关闭则会直接进入轻量级锁）
            2. BiasedLockingStartupDelay：偏向锁启动延迟
    3. 偏向锁的撤销
        * 当有另外的线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁。
        * 竞争线程尝试CAS更新对象头失败，会等待到<font color='green'>全局安全点</font>（此时不会执行任何代码）撤销偏向锁。
        * 撤销准备，检查持有偏向锁的线程是否还在执行：
            1. 第一个线程正在执行synchronized方法（处于同步块），它还没有执行完，其它线程来抢夺，该偏向锁会被取消掉并出现锁升级。此时轻量级锁由原持有偏向锁的线程持有，继续执行其同步代码，而正在竞争的线程会进入自旋等待获得该轻量锁。
            2. 第一个线程执行完成synchronized方法（退出同步块），则将对象头设置成无锁状态并撤销偏向锁，重新偏向。
3. 轻量级锁
* 多线程竞争，但是任意时刻最多只有一个线程竞争，即不存在锁竞争太激烈的情况，也就是没有线程阻塞。
* **本质就是自旋锁CAS**
* 加锁：
    * jvm会为每个线程再当前线程的栈帧中创建用于存储锁记录的空间，官方成为Displaced Mark Word。若一个线程发现线程是轻量级锁，会把锁的MarkWord复制到空间里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示MarkWord已经被替换成了其他线程的锁记录，说明在与其他线程竞争锁，当前线程就尝试使用自旋来获取锁。
* 释放：
    * 在释放锁时，当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级到了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。
* 升级：自适应自旋到一定程度会升级到重量锁。
4. 重量级锁
* 基于进入和退出Monitor对象实现。
## 锁升级之后，MrakWord中的hashCode去哪了？
* 当一个对象已经计算过了hashCode后，就不能升级到偏向锁了。
* 当一个对象已经是偏向锁状态了，需要计算hashCode，则偏向锁会立即升级为重量级锁，因为monitor中存储了非加锁状态的MarkWord。
* 针对轻量级锁，JVM会在线程的栈帧中创建一个锁记录（Lock Record）空间，用于存储锁对象的MarkWord拷贝，该拷贝中包含hashCode等信息，释放锁之后会将这些信息写回到对象头。
