## 公平锁和非公平锁
* 公平锁指多个线程按照申请锁的顺序来获取锁，类似排队买票。
  ` Lock lock = new ReentrantLock(true); `
* 非公平锁指多个线程获取锁的顺序并不是按照申请锁的顺序，又可能后申请的线程比先申请的线程优先获取锁，在高并发情况下，有可能造成优先级翻转或者饥饿的状态。
  ` Lock lock = new ReentrantLock(false); `
  ` Lock lock = new ReentrantLock(); `   
* 恢复挂起的线程到真正获取锁还是有时间差的，从开发人员看来这个时间微乎其微，但是从CPU的角度来看，这个时间差还是很明显的；所以非公平锁能充分的利用CPU的时间片，尽量减少CPU空闲状态时间。
* 使用多线程很重要的考量点就是线程切换的开销。当采用非公平锁时，***当一个线程请求锁获取同步状态，然后释放同步状态，刚释放锁的线程在此刻获取同步状态的概率变得非常大，所以就减少了线程的开销***。如果要实现更大的吞吐量，则需要选择非公平锁。

## 可重入锁
* 可以再次进入获取的锁。解决同步方法递归调用死锁的问题，或者在一个方法中嵌套获取锁的情况。
* 隐式可重入锁----synchronized  显式可重入锁-----ReentrantLock。
* 每个对象的底层代码中有owner和count两个属性，分别指代持有锁的线程以及锁的重入次数。  ----- lock和unlock必须要配对，否则会阻塞

## 死锁
* 死锁就是两个线程互相等待获取锁，即争抢资源。例如线程A持有锁A，线程B持有锁B，线程A正试图获取锁B，线程B正试图获取锁A。
* 排查死锁。通过jstack [程序进程号] 命令可以查看是否死锁。

## 线程中断
* void interrupt()、static boolean interrupted()、boolean isInterupted() 三个方法均和中断有关。
* 一个线程应该只由自己来中断。所以interrupt()方法是一种协作协商机制，调用该方法后，仅仅是将线程对象的中断标识设置为true，表示由线程请求中断此线程，至于该如何做需要自己写代码实现。
* static boolean interrupted() 方法判断线程是否被中断并清除中断状态

## 如何中断一个线程？
### 查看InterruptDemo系列的java类，可以深刻理解这个问题

## 等待唤醒
* LockSupport类。这个类没有构造方法，方法名都与park有关。其中park()和unpark()的作用分别时阻塞线程和解除阻塞线程。
* 3种方法可以让线程等待和唤醒。使用Object的wait()方法让线程带灯，使用Object的notify()方法唤醒；使用JUC包种Condition接口中的await()方法让线程等待，使用signal()方法唤醒；使用LockSupport类
* LockSupport类使用了许可证的思想，许可证只能有一个。