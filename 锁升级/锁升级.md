## 为什么？
* 用锁能够实现数据的安全性，但会带来性能下降。
* 无锁能够基于线程并行提升程序性能，但是会带来安全性下降。
* 在无锁和重量级锁之间寻求平衡，故引入锁升级机制。
## 升级过程
无锁---->偏向锁---->轻量级锁---->重量级锁
## jdk5之前
* synchronized锁在jdk5之前就是纯重量级锁，基于Monitor对象实现的。由于Monitor是jvm底层实现的，底层代码是c++，本质是依赖于底层操作系统的Mutex Lock实现的。操作系统实现线程之间的切换需要从用户态到内核态的转换，需要耗费大量资源、时间。
## Monitor与java对象以及线程是如何关联？
1. 如果一个java对象被某个线程锁住，则该java对象的MarkWord字段中的LockWord指向monitor的起始地址。
2. Monitor的Owner字段会存放拥有相关联对象锁的线程id。
## 提前知识
* 偏向锁：MarkWord存储的是偏向的线程ID
* 轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针
* 重量锁：MarkWord存储的是指向堆中的monitor对象的指针
## 锁升级流程
1. 
