## 无锁 --> 独占锁 --> 读写锁 --> 邮戳锁
## ReentrantLock
* 可重入独占锁
* 实现了Lock接口
## ReentrantReadWriteLock
1. 是什么？
    * 可重入读写锁
    * 实现了ReadWriteLock接口 ？---> 一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程。读写互斥、读读共享
2. 注意点：
    * 写锁饥饿问题：写操作太少了，写操作可能长时间抢不到锁。
    * 锁降级问题：遵循获得写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁。
        1. 如果同一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。
        2. 规则管理，先获取写锁，然后获取读锁，再释放写锁。
        3. 如果释放了写锁，那么就完全转换成读锁。
    * 是一种悲观的读锁。读锁必须要释放掉才能获取写锁。
## StampedLock
1. 是什么？
    * 邮戳锁，1.8新增的读写锁，对ReentrantReadWriteLock的优化。
    * 当释放锁或者转换锁时，都要传入最初获取的stamp的值。
2. 由饥饿问题引出的
    * 使用公平锁可以一定程度缓解，但是吞吐量下降
3. StampedLock的特点
    * 一种乐观的读锁。有线程获取到读锁时其他线程获取写锁时不会被阻塞。
    * 获取锁的方法返回一个Stamp，Stamp为零代表获取失败。
    * 释放锁的方法需要一个Stamp，这个Stamp必须和成功获取到锁时的Stamp一致。
    * StampedLock是不可重入的。
    * 有三种访问模式：Reading、Writing、Optimistic reading
4. 缺点：
    * 不支持重入。
    * 不支持条件变量Condition。
    * 一定不要调用中断操作，即interrupt()方法。

