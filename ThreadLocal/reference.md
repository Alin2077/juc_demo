## 整体架构
![整体架构](./bbb.jpg)
java允许我们重写finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作
## 强引用
* 最常见的普通对象引用就是强引用
* 当内存不足时，JVM开始垃圾回收，对于强引用的对象，<font color='green'>就算是出现了OOM也不会对该对象进行回收</font>
## 软引用
* 是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集
* <font color='green'>当系统内存充足时，不会回收；系统内存不足时，回收</font>
* 通常用在对内存敏感的程序中，比如高速缓存
## 弱引用
* 需要用java.lang.ref.WeakReference类来实现，它比软引用的生存期更短
* 只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收
## 软引用与弱引用的适用场景
* 假如有一个应用需要读取大量图片：
    * 如果每次读取图片都从硬盘读取会严重影响性能
    * 如果一次性全部加载到内存中有可能造成内存溢出
    * 用一个hashmap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片所占用的空间，从而有效地避免了OOM的问题
```java
Map<String,SoftReference<Bitmap>> imageCache = new HashMap<String,SoftReference<Bitmap>>();
```
## 虚引用
1. 虚引用必须和引用队列（ReferenceQueue）联合适用
    * 虚引用需要java.lang.ref.PhantomReference类来实现
    * 虚引用并不会决定对象的生命周期
    * 如果一个对象仅持有虚引用，在任何时候都可能被垃圾回收器回收
    * 虚引用不能单独使用也不能访问对象（即无法使用geyt()），必须和引用队列联合使用
2. PhantomReference的get()方法总是返回null
    * 虚引用的主要作用时跟踪对象被垃圾回收的状态。<font color='green'>提供了一种确保对象被finalize以后，做某些事情的通知机制</font>
3. 处理监控通知使用
    * 设置虚引关联对象的唯一目的，就是在这个对象被收集器后手的时候收到一个系统通知或者后续添加进一步的处理，用来实现比finalize机制更灵活的回收操作
